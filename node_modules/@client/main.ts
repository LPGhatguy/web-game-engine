import Matrix4x4 from "typed-math/Matrix4x4";
import PerspectiveCamera from "./PerspectiveCamera";
import FPSCameraController from "./FPSCameraController";
import Texture from "./graphics/Texture";
import Mesh from "./graphics/Mesh";
import WavefrontLoader from "./graphics/WavefrontLoader";
import InputManager from "./input/InputManager";
import Net from "./Net";

import BaseFrag from "./shaders/BaseFrag";
import BaseVert from "./shaders/BaseVert";

import Engine from "./Engine";

let engine = new Engine();
let gl;

let vertices;

let cam, controller;

let tModel, tView;

let meshes: Mesh[] = [];

engine.onLoad.subscribe(() => {
	return Net.get("/test.obj")
		.then(body => {
			let loader = new WavefrontLoader();
			loader.load(body);
			vertices = loader.buffer.internal;
		});
});

engine.onLoad.subscribe(() => {
	engine.logAwesome("Hi! Welcome to Meanwhile in Sector 80!");

	gl = engine.gl;

	cam = new PerspectiveCamera(70, engine.canvas.width / engine.canvas.height, 0.1, 100);
	controller = new FPSCameraController(cam);

	gl.enable(gl.DEPTH_TEST);
	gl.enable(gl.CULL_FACE);

	gl.enable(gl.BLEND);

	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

	gl.clearColor(0.25, 0.25, 0.25, 1);
	gl.clear(gl.COLOR_BUFFER_BIT);

	let triBuffer = gl.createBuffer();
	gl.bindBuffer(gl.ARRAY_BUFFER, triBuffer);
	gl.bufferData(gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW);

	let frag = BaseFrag.compile(gl);
	let vert = BaseVert.compile(gl);

	let program = gl.createProgram();
	gl.attachShader(program, frag);
	gl.attachShader(program, vert);
	gl.linkProgram(program);

	if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
		throw new Error("Couldn't initialize shaders!");
	}

	let posAttrib = gl.getAttribLocation(program, "position");
	gl.enableVertexAttribArray(posAttrib);
	gl.vertexAttribPointer(posAttrib, 3, gl.FLOAT, false, 8 * 4, 0);

	let texcoordAttrib = gl.getAttribLocation(program, "texcoord");
	gl.enableVertexAttribArray(texcoordAttrib);
	gl.vertexAttribPointer(texcoordAttrib, 2, gl.FLOAT, false, 8 * 4, 3 * 4);

	let normalAttrib = gl.getAttribLocation(program, "normalVector");
	gl.enableVertexAttribArray(normalAttrib);
	gl.vertexAttribPointer(normalAttrib, 3, gl.FLOAT, false, 8 * 4, 5 * 4);

	Texture.load(gl, "/images/bleh.png")
		.then((texture) => {
			let texUniform = gl.getUniformLocation(program, "tex");
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture.texture);
			gl.uniform1i(texUniform, 0);
		});

	tModel = gl.getUniformLocation(program, "transformModel");
	tView = gl.getUniformLocation(program, "transformView");
	let tProjection = gl.getUniformLocation(program, "transformProjection");

	for (let i = 0; i < 1; i++) {
		let mesh = new Mesh(engine);
		mesh.position.x = i;

		meshes.push(mesh);
	}

	gl.useProgram(program);

	gl.uniformMatrix4fv(tModel, false, new Matrix4x4().array);
	gl.uniformMatrix4fv(tView, false, cam.getViewMatrix().array);
	gl.uniformMatrix4fv(tProjection, false, cam.getProjectionMatrix().array);
});

engine.onUpdate.subscribe((dt: number) => {
	controller.update(dt);

	for (let mesh of meshes) {
		mesh.position.z = -1;
		mesh.position.y = Math.abs(Math.sin(engine.timer.total() / 1000));

		mesh.transformDirty = true;
	}
});

engine.onDraw.subscribe((dt: number) => {
	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	gl.uniformMatrix4fv(tView, false, cam.getViewMatrix().array);

	for (let mesh of meshes) {
		gl.uniformMatrix4fv(tModel, false, mesh.getTransformMatrix().array);
		gl.drawArrays(gl.TRIANGLES, 0, vertices.length / 8);
	}
});

engine.main();