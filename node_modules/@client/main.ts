import "core-js";

import Engine from "./Engine";

import Vector3 from "typed-math/Vector3";
import PerspectiveCamera from "./PerspectiveCamera";
import FPSCameraController from "./FPSCameraController";
import Texture from "./graphics/Texture";
import Mesh from "./graphics/Mesh";
import WavefrontLoader from "./graphics/WavefrontLoader";
import Net from "./Net";

import ShaderProgram from "./graphics/ShaderProgram";
import BaseFrag from "./shaders/BaseFrag";
import BPFrag from "./shaders/BPFrag";
import BaseVert from "./shaders/BaseVert";

let engine = new Engine();

let cube: Mesh, cubeGeometry;
let plane: Mesh, planeGeometry;

let cam: PerspectiveCamera;
let controller: FPSCameraController;

let meshes: Mesh[] = [];

engine.onLoad.subscribe(() => {
	return Net.get("/cube.obj")
		.then(body => {
			let loader = new WavefrontLoader();
			loader.load(body);
			cubeGeometry = loader.geometry;

			return Net.get("/plane.obj");
		})
		.then(body => {
			let loader = new WavefrontLoader();
			loader.load(body);
			planeGeometry = loader.geometry;
		});
});

engine.onLoad.subscribe(() => {
	engine.logAwesome("Hi! Welcome to the WGE demo!");

	let gl = engine.gl;

	gl.enable(gl.CULL_FACE);
	gl.cullFace(gl.BACK);

	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LESS);

	// gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

	gl.clearColor(0.25, 0.25, 0.25, 1);
	gl.clear(gl.COLOR_BUFFER_BIT);

	let frag = BPFrag.compile(gl);
	let vert = BaseVert.compile(gl);

	let sp = new ShaderProgram(engine);
	sp.attach(frag, vert);
	sp.link();
	sp.use();

	sp.addUniforms("tex");
	sp.addUniforms("transformModel", "transformView", "transformProjection");
	sp.addAttributes("position", "texcoord", "normalVector");
	sp.enableAttributes("position", "texcoord", "normalVector");

	let program = sp.program;

	Texture.load(gl, "/images/uv-test.png")
		.then((texture) => {
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture.texture);
			gl.uniform1i(sp.uniforms["tex"], 0);
		});

	let tProjection = sp.uniforms["transformProjection"];

	cube = new Mesh(engine);
	cube.geometry = cubeGeometry;
	meshes.push(cube);

	plane = new Mesh(engine);
	plane.geometry = planeGeometry;
	plane.scale.x = plane.scale.z = 100;
	meshes.push(plane);

	cam = new PerspectiveCamera(70, engine.canvas.width / engine.canvas.height, 0.1, 100);
	cam.position.y = 4;
	controller = new FPSCameraController(cam);

	gl.uniformMatrix4fv(tProjection, false, cam.getProjectionMatrix().array);
});

engine.onUpdate.subscribe((dt: number) => {
	controller.update(dt);

	let scale = 5;
	let t = engine.timer.total() / 1000;

	cube.position.y = 4;
	cube.position.x = scale * Math.cos(t);
	cube.position.z = scale * Math.sin(t);
	cube.transformDirty = true;

	(<HTMLElement>document.querySelector(".debug")).innerHTML = `
		Camera: ${cam.position.toString()}<br />
		Box: ${cube.position.toString()}
	`;
});

engine.onDraw.subscribe((dt: number) => {
	let gl = engine.gl;

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	gl.uniformMatrix4fv(engine.currentProgram.uniforms["transformView"], false, cam.getViewMatrix().array);

	for (let mesh of meshes) {
		mesh.draw();
	}
});

engine.main();