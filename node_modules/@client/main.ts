// import "core-js";

import Engine from "./Engine";

import Vector3 from "typed-math/Vector3";
import PerspectiveCamera from "./PerspectiveCamera";
import FPSCameraController from "./FPSCameraController";
import Texture, {TextureType} from "./graphics/Texture";
import Geometry from "./graphics/Geometry";
import Mesh from "./graphics/Mesh";
import WavefrontLoader from "./graphics/WavefrontLoader";
import Net from "./Net";

import ShaderProgram from "./graphics/ShaderProgram";
import BaseFrag from "./shaders/BaseFrag";
import BPFrag from "./shaders/BPFrag";
import BaseVert from "./shaders/BaseVert";

import DeferredVert from "./shaders/DeferredVert";
import DeferredVertPass from "./shaders/DeferredVertPass";
import DeferredFragPass from "./shaders/DeferredFragPass";
import DeferredFragLight from "./shaders/DeferredFragLight";

import DynamicBuffer from "@common/DynamicBuffer";

let engine = new Engine();

let cube: Mesh, cubeGeometry;
let plane: Mesh, planeGeometry;
let fsquad: Mesh, fsquadGeometry: Geometry;

let cam: PerspectiveCamera;
let controller: FPSCameraController;

let prepassShader: ShaderProgram;
let lightShader: ShaderProgram;

let fb: WebGLFramebuffer;

let depthTexture: Texture;
let normalTexture: Texture;
let positionTexture: Texture;
let colorTexture: Texture;

let meshes: Mesh[] = [];

engine.onLoad.subscribe(() => {
	return Net.get("/cube.obj")
		.then(body => {
			let loader = new WavefrontLoader();
			loader.load(body);
			cubeGeometry = loader.geometry;

			return Net.get("/plane.obj");
		})
		.then(body => {
			let loader = new WavefrontLoader();
			loader.load(body);
			planeGeometry = loader.geometry;
		});
});

engine.onLoad.subscribe(() => {
	engine.logAwesome("Hi! Welcome to the WGE demo!");

	let gl = engine.gl;

	// gl.enable(gl.CULL_FACE);
	// gl.cullFace(gl.BACK);

	gl.enable(gl.DEPTH_TEST);
	gl.depthFunc(gl.LESS);

	// gl.enable(gl.BLEND);
	gl.blendEquation(gl.FUNC_ADD);
	gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

	gl.clearColor(0.25, 0.25, 0.25, 1);
	gl.clear(gl.COLOR_BUFFER_BIT);

	fsquadGeometry = new Geometry();
	fsquadGeometry.addVertex([1, 1, 0], [1, 1], [0, 0, 1]);
	fsquadGeometry.addVertex([-1, 1, 0], [0, 1], [0, 0, 1]);
	fsquadGeometry.addVertex([-1, -1, 0], [0, 0], [0, 0, 1]);

	fsquadGeometry.addVertex([-1, -1, 0], [0, 0], [0, 0, 1]);
	fsquadGeometry.addVertex([1, -1, 0], [1, 0], [0, 0, 1]);
	fsquadGeometry.addVertex([1, 1, 0], [1, 1], [0, 0, 1]);
	fsquadGeometry.finish();
	fsquadGeometry.upload(engine);

	fsquad = new Mesh(engine);
	fsquad.geometry = fsquadGeometry;

	let w = engine.canvas.width;
	let h = engine.canvas.height;

	depthTexture = Texture.createEmpty(engine, w, h, TextureType.Depth);
	normalTexture = Texture.createEmpty(engine, w, h, TextureType.ColorFloat);
	positionTexture = Texture.createEmpty(engine, w, h, TextureType.ColorFloat);
	colorTexture = Texture.createEmpty(engine, w, h, TextureType.ColorFloat);

	let dvert = DeferredVert.compile(gl);
	let dfragpass = DeferredFragPass.compile(gl);

	prepassShader = new ShaderProgram(engine);
	prepassShader.attach(dvert, dfragpass);
	prepassShader.link();
	prepassShader.use();

	let dvertpass = DeferredVertPass.compile(gl);
	let dfraglight = DeferredFragLight.compile(gl);

	lightShader = new ShaderProgram(engine);
	lightShader.attach(dvertpass, dfraglight);
	lightShader.link();

	prepassShader.addUniforms("tex");
	prepassShader.addUniforms("transformModel", "transformView", "transformProjection");
	prepassShader.addAttributes("position", "texcoord", "normalVector");
	prepassShader.enableAttributes("position", "texcoord", "normalVector");

	lightShader.addAttributes("position", "texcoord", "normalVector");
	lightShader.enableAttributes("position", "texcoord", "normalVector");
	lightShader.addUniforms("u_color", "u_depth", "u_normal", "u_position");

	let program = prepassShader.program;

	let ext: WEBGL_draw_buffers = gl.getExtension("WEBGL_draw_buffers");
	fb = gl.createFramebuffer();
	gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.TEXTURE_2D, depthTexture.texture, 0);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT0_WEBGL, gl.TEXTURE_2D, normalTexture.texture, 0);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT1_WEBGL, gl.TEXTURE_2D, positionTexture.texture, 0);
	gl.framebufferTexture2D(gl.FRAMEBUFFER, ext.COLOR_ATTACHMENT2_WEBGL, gl.TEXTURE_2D, colorTexture.texture, 0);

	ext.drawBuffersWEBGL([
		ext.COLOR_ATTACHMENT0_WEBGL,
		ext.COLOR_ATTACHMENT1_WEBGL,
		ext.COLOR_ATTACHMENT2_WEBGL,
		gl.NONE
	]);

	gl.bindFramebuffer(gl.FRAMEBUFFER, null);

	Texture.load(engine, "/images/uv-test.png")
		.then((texture) => {
			prepassShader.use();
			gl.activeTexture(gl.TEXTURE0);
			gl.bindTexture(gl.TEXTURE_2D, texture.texture);
			gl.uniform1i(prepassShader.uniforms["tex"], 0);
		});

	let tProjection = prepassShader.uniforms["transformProjection"];

	cube = new Mesh(engine);
	cube.geometry = cubeGeometry;
	meshes.push(cube);

	plane = new Mesh(engine);
	plane.geometry = planeGeometry;
	plane.scale.x = plane.scale.z = 100;
	meshes.push(plane);

	cam = new PerspectiveCamera(70, engine.canvas.width / engine.canvas.height, 0.1, 100);
	cam.position.y = 4;
	controller = new FPSCameraController(cam);

	gl.uniformMatrix4fv(tProjection, false, cam.getProjectionMatrix().array);
});

engine.onUpdate.subscribe((dt: number) => {
	controller.update(dt);

	let scale = 5;
	let t = engine.timer.total() / 1000;

	cube.position.y = 4;
	cube.position.x = scale * Math.cos(t);
	cube.position.z = scale * Math.sin(t);
	cube.transformDirty = true;

	// let gl = engine.gl;
	// (<HTMLElement>document.querySelector(".debug")).innerText =
	// `Depth: ${gl.isEnabled(gl.DEPTH_TEST) ? "yes" : "no"}
	// `;
});

engine.onDraw.subscribe((dt: number) => {
	let gl = engine.gl;

	gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

	gl.activeTexture(gl.TEXTURE1);
	colorTexture.clear();
	normalTexture.clear();
	positionTexture.clear();
	depthTexture.clear();

	prepassShader.use();

	gl.uniformMatrix4fv(engine.currentProgram.uniforms["transformView"], false, cam.getViewMatrix().array);

	gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
	for (let mesh of meshes) {
		mesh.draw();
	}
	gl.bindFramebuffer(gl.FRAMEBUFFER, null);

	lightShader.use();

	gl.activeTexture(gl.TEXTURE1);
	gl.bindTexture(gl.TEXTURE_2D, colorTexture.texture);
	gl.uniform1i(lightShader.uniforms["u_color"], 1);

	gl.activeTexture(gl.TEXTURE2);
	gl.bindTexture(gl.TEXTURE_2D, normalTexture.texture);
	gl.uniform1i(lightShader.uniforms["u_normal"], 2);

	gl.activeTexture(gl.TEXTURE3);
	gl.bindTexture(gl.TEXTURE_2D, positionTexture.texture);
	gl.uniform1i(lightShader.uniforms["u_position"], 3);

	gl.activeTexture(gl.TEXTURE4);
	gl.bindTexture(gl.TEXTURE_2D, depthTexture.texture);
	gl.uniform1i(lightShader.uniforms["u_depth"], 4);

	fsquad.draw();
});

engine.main();