import DynamicBuffer from "@common/DynamicBuffer";
import Engine from "@client/Engine";

export class GeometryUsage {
	dynamic: boolean = false;

	toGL(gl: WebGLRenderingContext): number {
		return this.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
	}
}

let unitUsage = new GeometryUsage();

export interface GeometryData {
	vertices: number[][],
	texcoords: number[][],
	normals: number[][]
}

export class PackingMode {
	vertices: boolean = true;
	texcoords: boolean = true;
	normals: boolean = true;
}

let unitPackingMode = new PackingMode();

// TODO: use VAOs, EBOs, and be all optimized and stuff
// TODO: one glBuffer per engine?
export default class Geometry {
	vertexCount: number = 0;
	glBuffer: WebGLBuffer;

	packed: boolean = false;
	uploaded: boolean = false;

	/**
	 * Whether the original, friendly data should be preserved after packing.
	 */
	preserveSourceAfterPacking: boolean = false;

	/**
	 * Whether the packed vertex data should be retained after upload.
	 */
	preservePackedAfterUpload: boolean = false;

	protected source: GeometryData;
	protected buffer: DynamicBuffer;
	protected packingMode: PackingMode;

	// TODO: mode parameter?
	constructor() {
		// TODO: special-purpose buffers?
		this.source = {
			vertices: [],
			texcoords: [],
			normals: []
		}
	}

	pack(mode: PackingMode = unitPackingMode) {
		if (this.source == null) {
			throw new Error("Can't pack vertices without source data! Was it destroyed on upload?");
		}

		this.packingMode = mode;

		let len = this.source.vertices.length;

		if (this.buffer == null) {
			this.buffer = new DynamicBuffer(Float32Array, len);
		} else {
			this.buffer.clear();
		}

		let vertices = this.source.vertices;
		let texcoords = this.source.texcoords;
		let normals = this.source.normals;

		for (let i = 0; i < len; i++) {
			if (mode.vertices) {
				this.buffer.concat(vertices[i]);
			}

			if (mode.texcoords) {
				this.buffer.concat(texcoords[i]);
			}

			if (mode.normals) {
				this.buffer.concat(normals[i]);
			}
		}

		this.packed = true;

		if (!this.preserveSourceAfterPacking) {
			// BE FREE!
			this.source = null;
		}
	}

	upload(engine: Engine, usage: GeometryUsage = unitUsage) {
		let gl = engine.gl;

		if (!this.packed) {
			// Should this throw a warning?
			this.pack();
		}

		if (!this.uploaded) {
			this.glBuffer = gl.createBuffer();
		}

		gl.bindBuffer(gl.ARRAY_BUFFER, this.glBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, this.buffer.internal, usage.toGL(gl));

		this.uploaded = true;

		if (!this.preservePackedAfterUpload) {
			this.buffer = null;
		}
	}

	bind(engine: Engine) {
		let gl = engine.gl;
		let program = engine.currentProgram;

		if (this.uploaded) {
			engine.gl.bindBuffer(engine.gl.ARRAY_BUFFER, this.glBuffer);
		} else {
			this.upload(engine);
		}

		program.enableAttributes("position", "texcoord", "normalVector");

		let pos = 0;
		let stride =
			(this.packingMode.vertices ? 3 * 4 : 0) +
			(this.packingMode.texcoords ? 2 * 4 : 0) +
			(this.packingMode.normals ? 3 * 4 : 0);

		if (this.packingMode.vertices) {
			gl.vertexAttribPointer(program.attributes["position"], 3, gl.FLOAT, false, stride, pos);
			pos += 3 * 4;
		}

		if (this.packingMode.texcoords) {
			gl.vertexAttribPointer(program.attributes["texcoord"], 2, gl.FLOAT, false, stride, pos);
			pos += 2 * 4;
		}

		if (this.packingMode.normals) {
			gl.vertexAttribPointer(program.attributes["normalVector"], 3, gl.FLOAT, false, stride, pos);
			pos += 3 * 4;
		}
	}

	// TODO: replace with getter?
	getBuffer() {
		return this.buffer.internal;
	}

	// GOTCHA: these arrays aren't copied; you have to do that if you're going to reuse them
	addVertex(vertex: number[], texcoord: number[], normal: number[]) {
		if (this.source == null) {
			throw new Error("Can't add vertices without source data! Was it destroyed on upload?");
		}

		this.source.vertices.push(vertex);
		this.source.texcoords.push(texcoord);
		this.source.normals.push(normal);

		this.vertexCount++;
	}
}