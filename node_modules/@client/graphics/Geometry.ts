import DynamicBuffer from "@common/DynamicBuffer";
import Engine from "@client/Engine";

export class GeometryUsage {
	dynamic: boolean = false;

	toGL(gl: WebGLRenderingContext): number {
		return this.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;
	}
}

let unitUsage = new GeometryUsage();

// TODO: use VAOs, EBOs, and be all optimized and stuff
// TODO: one glBuffer per engine?
export default class Geometry {
	vertexCount: number = 0;
	glBuffer: WebGLBuffer;
	uploaded: boolean = false;

	private buffer: DynamicBuffer;

	constructor(length: number = 64) {
		if (length >= 0) {
			this.buffer = new DynamicBuffer(Float32Array, length);
		}
	}

	upload(engine: Engine, usage: GeometryUsage = unitUsage) {
		let gl = engine.gl;

		if (!this.uploaded) {
			this.glBuffer = gl.createBuffer();
			this.uploaded = true;
		}

		gl.bindBuffer(gl.ARRAY_BUFFER, this.glBuffer);
		gl.bufferData(gl.ARRAY_BUFFER, this.getBuffer(), usage.toGL(gl));
	}

	bind(engine: Engine) {
		let gl = engine.gl;
		let program = engine.currentProgram;

		if (this.uploaded) {
			engine.gl.bindBuffer(engine.gl.ARRAY_BUFFER, this.glBuffer);
		} else {
			this.upload(engine);
		}

		program.enableAttributes("position", "texcoord", "normalVector");
		gl.vertexAttribPointer(program.attributes["position"], 3, gl.FLOAT, false, 8 * 4, 0);
		gl.vertexAttribPointer(program.attributes["texcoord"], 2, gl.FLOAT, false, 8 * 4, 3 * 4);
		gl.vertexAttribPointer(program.attributes["normalVector"], 3, gl.FLOAT, false, 8 * 4, 5 * 4);
	}

	getBuffer() {
		return this.buffer.internal;
	}

	addVertex(vertex: number[], texcoord: number[], normal: number[]) {
		this.buffer.concat([].concat(vertex, texcoord, normal));
		this.vertexCount++;
	}

	finish() {
		this.buffer.shrink();
	}
}