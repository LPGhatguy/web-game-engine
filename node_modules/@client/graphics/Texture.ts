import Engine from "@client/Engine";

export enum TextureType {
	Color,
	ColorFloat,
	Depth
}

export default class Texture {
	engine: Engine;

	source: string;
	width: number;
	height: number;
	type: TextureType;
	texture: WebGLTexture;
	image: HTMLImageElement;

	constructor(engine: Engine) {
		this.engine = engine;
	}

	static createEmpty(engine: Engine, w: number, h: number, type: TextureType) {
		let gl = engine.gl;
		let format, component;

		switch (type) {
			case TextureType.Color:
				format = gl.RGBA;
				component = gl.UNSIGNED_BYTE;
				break;

			case TextureType.ColorFloat:
				format = gl.RGBA;
				component = gl.FLOAT;
				break;

			case TextureType.Depth:
				format = gl.DEPTH_COMPONENT;
				component = gl.UNSIGNED_SHORT;
				break;
		}

		let self = new Texture(engine);
		self.type = type;
		self.width = w;
		self.height = h;

		self.texture = gl.createTexture();
		gl.bindTexture(gl.TEXTURE_2D, self.texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texImage2D(gl.TEXTURE_2D, 0, format, w, h, 0, format, component, null);

		return self;
	}

	static load(engine: Engine, src: string): Promise<Texture> {
		let gl = engine.gl;
		let self = new Texture(engine);

		self.source = src;
		self.type = TextureType.Color;

		self.texture = gl.createTexture();
		self.image = new Image();

		return new Promise<Texture>(resolve => {
			self.image.onload = () => {
				self.width = self.image.width;
				self.height = self.image.height;

				gl.bindTexture(gl.TEXTURE_2D, self.texture);
				gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, self.image);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
				gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
				gl.texParameterf(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
				gl.generateMipmap(gl.TEXTURE_2D);

				resolve(self);
			};

			self.image.src = src;
		});
	}

	clear() {
		let gl = this.engine.gl;
		let format, component;

		switch (this.type) {
			case TextureType.Color:
				format = gl.RGBA;
				component = gl.UNSIGNED_BYTE;
				break;

			case TextureType.ColorFloat:
				format = gl.RGBA;
				component = gl.FLOAT;
				break;

			case TextureType.Depth:
				format = gl.DEPTH_COMPONENT;
				component = gl.UNSIGNED_SHORT;
				break;
		}

		gl.bindTexture(gl.TEXTURE_2D, this.texture);
		gl.texImage2D(gl.TEXTURE_2D, 0, format, this.width, this.height, 0, format, component, null);
	}
}