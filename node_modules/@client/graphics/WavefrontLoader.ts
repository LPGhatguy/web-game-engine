import Vector3 from "typed-math/Vector3";
import DynamicF32 from "@common/DynamicF32";
import Geometry from "./Geometry";

export type WavefrontOp = (loader: WavefrontLoader, line: string, op: string, args: string) => void;

const identityVertex = [0, 0, 0];
const identityTex = [0, 0];
const identityNormal = [0, 0, 0];

const comment = "#";
const whitespace = {
	" ": true,
	"\t": true,
	"\r": true,
	"\n": true
};

const ops: {[name: string]: WavefrontOp} = {
	v: (loader, line, op, args) => {
		loader.vertices.push(args.split(" ", 3).map(parseFloat));
	},
	vt: (loader, line, op, args) => {
		loader.texcoords.push(args.split(" ", 2).map(parseFloat));
	},
	vn: (loader, line, op, args) => {
		loader.normals.push(args.split(" ", 3).map(parseFloat));
	},
	f: (loader, line, op, args) => {
		let points = args.split(" ");
		let vertices = [];

		for (let point of points) {
			let v, vt, vn;

			let simple = parseFloat(point);
			if (!isNaN(simple)) {
				v = vt = vn = simple;
			}

			let dsplit = point.split("/").map(parseFloat);
			dsplit[1] = dsplit[1] || dsplit[0];
			dsplit[2] = dsplit[2] || dsplit[0];

			let [vid, vtid, vnid] = dsplit;
			let vertex = loader.vertices[vid - 1];
			let texcoord = loader.texcoords[vtid - 1];
			let normal = loader.normals[vnid - 1];

			if (!vertex) {
				console.warn("INVALID VERTEX", vid);
				return;
			}

			texcoord = texcoord || identityTex;
			normal = normal || identityNormal;

			vertices.push([vertex, texcoord, normal]);
		}

		// Handle triangulated and quadrangulated vertices
		if (vertices.length === 3) {
			for (let vertex of vertices) {
				loader.geometry.addVertex(vertex[0], vertex[1], vertex[2]);
			}
		} else if (vertices.length === 4) {
			for (let i = 0; i < 3; i++) {
				let [vertex, texcoord, normal] = vertices[i];
				loader.geometry.addVertex(vertex, texcoord, normal);
			}

			for (let i = 2; i < 5; i++) {
				let [vertex, texcoord, normal] = vertices[i % 4];
				loader.geometry.addVertex(vertex, texcoord, normal);
			}
		}
	}
};

export default class WavefrontLoader {
	vertices: any[];
	colors: any[];
	texcoords: any[];
	normals: any[];

	geometry: Geometry;

	constructor() {
		this.reset();
	}

	reset() {
		this.vertices = [];
		this.colors = [];
		this.texcoords = [];
		this.normals = [];

		this.geometry = new Geometry();
	}

	load(source: string) {
		let lines = source.split("\n");

		for (let line of lines) {
			let match = line.match(/^\s*([^\s]+)\s*(.+)/);

			if (!match) {
				continue;
			}

			let [whole, op, args] = match;

			if (op === comment) {
				continue;
			}

			if (ops[op]) {
				ops[op](this, line, op, args);
			} else {
				console.warn(`Unrecognized OBJ opcode "${op}"`);
			}
		}

		this.geometry.finish();
	}
}